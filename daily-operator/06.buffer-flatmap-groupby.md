# [buffer](http://reactivex.io/documentation/operators/buffer.html)
발생되는 항목들을 주기적으로 모아서 한 번에 던집니다.<br>
![Buffer.png](http://reactivex.io/documentation/operators/images/Buffer.png)

### 샘플 코드
```java
// RxJava1
public static void main(String[] args) {
    Observable
            .create((Observable.OnSubscribe<Integer>) observer -> {
                System.out.println("Thread:" + Thread.currentThread().getName() + "\tEmit items.");
                try {
                    if (!observer.isUnsubscribed()) {
                        for (int i = 1; i <= 10; i++) {
                            observer.onNext(i);
                        }
                        observer.onCompleted();
                    }
                } catch (Exception e) {
                    observer.onError(e);
                }
            })
            .buffer(2, 4) // 1,2번째는 발생시키고, 3,4번째는 스킵, 다시 5,6는 발생시킵니다.
            .doOnEach(notification -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tEach: " + notification))
            .subscribeOn(Schedulers.computation())
            .observeOn(Schedulers.io())
            .map((List<Integer> bufferedItems) -> {
                System.out.println("Thread:" + Thread.currentThread().getName() + "\tMap: " + bufferedItems);
                return bufferedItems.get(0);
            })
            .observeOn(Schedulers.newThread())
            .doOnNext((Integer item) -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tonNext: " + item))
            .observeOn(Schedulers.io())
            .doOnCompleted(() -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tonCompleted")) 
            .observeOn(Schedulers.computation())
            .doOnError(e -> System.err.println("Thread:" + Thread.currentThread().getName() + "\tonError: " + e.getMessage()))
            .subscribe();

    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```
<br>
<br>

# [flatMap](http://reactivex.io/documentation/operators/flatmap.html)
현재 Observable에 의해 발생되는 항목들 중 Observable이 있다면 그 Observable이 발생시킨 항목들도 현재 스트림에서 흐르게 합니다. 항목들의 항목들도 하나의 흐름으로 merge 시키는 겁니다.

![flatMap.c.png](http://reactivex.io/documentation/operators/images/flatMap.c.png)

### 샘플 코드
```java
// RxJava1
public static void main(String[] args) {
    Observable
            .create((Observable.OnSubscribe<Integer[]>) observer -> {
                System.out.println("Thread:" + Thread.currentThread().getName() + "\tEmit items.");
                try {
                    if (!observer.isUnsubscribed()) {
                        for (int i = 1; i <= 5; i++) {
                            observer.onNext(new Integer[]{1, 2});
                        }
                        observer.onCompleted();
                    }
                } catch (Exception e) {
                    observer.onError(e);
                }
            })
            .observeOn(Schedulers.io())
            .doOnEach(notification -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tEachBeforeFlatMap: " + notification))
            .observeOn(Schedulers.newThread())
            .flatMap(new Func1<Integer[], Observable<Integer>>() {
                @Override
                public Observable<Integer> call(Integer[] ints) {
                    return Observable.from(ints);
                }
            })
            .doOnEach(notification -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tEachAfterFlatMap: " + notification))
            .subscribeOn(Schedulers.computation())
            .observeOn(Schedulers.io())
            .map((Integer item) -> {
                System.out.println("Thread:" + Thread.currentThread().getName() + "\tMap: " + item);
                return item * item;
            })
            .observeOn(Schedulers.newThread())
            .doOnNext((Integer item) -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tonNext: " + item))
            .observeOn(Schedulers.io())
            .doOnCompleted(() -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tonCompleted")) // 호출되지 않습니다.
            .observeOn(Schedulers.computation())
            .doOnError(e -> System.err.println("Thread:" + Thread.currentThread().getName() + "\tonError: " + e.getMessage()))
            .subscribe();   

    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```
<br>
<br>

# [groupBy](http://reactivex.io/documentation/operators/groupby.html)
현재 Observable이 발생시키는 아이템들을 key로 그룹핑해서 새로운 Observable들을 발생시킵니다.

![groupBy.c.png](http://reactivex.io/documentation/operators/images/groupBy.c.png)

### 샘플 코드
```java
// RxJava1
public static void main(String[] args) {
    Observable
            .create((Observable.OnSubscribe<Integer>) observer -> {
                System.out.println("Thread:" + Thread.currentThread().getName() + "\tEmit items.");
                try {
                    if (!observer.isUnsubscribed()) {
                        for (int i = 1; i <= 5; i++) {
                            observer.onNext(i);
                        }
                        observer.onCompleted();
                    }
                } catch (Exception e) {
                    observer.onError(e);
                }
            })
            .observeOn(Schedulers.io())
            .doOnEach(notification -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tEachBeforeGroupBy: " + notification))
            .observeOn(Schedulers.computation())
            .groupBy(new Func1<Integer, Boolean>() {
                @Override
                public Boolean call(Integer item) {
                    return item % 2 == 0; /*짝수그룹, 홀수그룹으로 나눕니다.*/
                }
            })
            .doOnEach(notification -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tEachAfterGroupBy: " + notification))
            .observeOn(Schedulers.io())
            .flatMap(new Func1<GroupedObservable<Boolean, Integer>, Observable<Integer>>() {
                @Override
                public Observable<Integer> call(GroupedObservable<Boolean, Integer> booleanIntegerGroupedObservable) {
                    return booleanIntegerGroupedObservable;
                }
            })
            .subscribeOn(Schedulers.computation())
            .observeOn(Schedulers.newThread())
            .doOnNext((Integer item) -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tonNext: " + item))
            .observeOn(Schedulers.io())
            .doOnCompleted(() -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tonCompleted")) // 호출되지 않습니다.
            .observeOn(Schedulers.computation())
            .doOnError(e -> System.err.println("Thread:" + Thread.currentThread().getName() + "\tonError: " + e.getMessage()))
            .subscribe();

    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```