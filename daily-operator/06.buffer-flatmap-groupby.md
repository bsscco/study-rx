# [buffer](http://reactivex.io/documentation/operators/buffer.html)
발생되는 항목들을 주기적으로 모아서 한 번에 던집니다.<br>
![Buffer.png](http://reactivex.io/documentation/operators/images/Buffer.png)

### 샘플 코드
```java
// RxJava1
public static void main(String[] args) {
    Observable
            .create((Observable.OnSubscribe<Integer>) observer -> {
                System.out.println("Thread:" + Thread.currentThread().getName() + "\tEmit items.");
                try {
                    if (!observer.isUnsubscribed()) {
                        for (int i = 1; i <= 10; i++) {
                            observer.onNext(i);
                        }
                        observer.onCompleted();
                    }
                } catch (Exception e) {
                    observer.onError(e);
                }
            })
            .buffer(2, 4) // 1,2번째는 발생시키고, 3,4번째는 스킵, 다시 5,6는 발생시킵니다.
            .doOnEach(notification -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tEach: " + notification))
            .subscribeOn(Schedulers.computation())
            .observeOn(Schedulers.io())
            .map((List<Integer> bufferedItems) -> {
                System.out.println("Thread:" + Thread.currentThread().getName() + "\tMap: " + bufferedItems);
                return bufferedItems.get(0);
            })
            .observeOn(Schedulers.newThread())
            .doOnNext((Integer item) -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tonNext: " + item))
            .observeOn(Schedulers.io())
            .doOnCompleted(() -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tonCompleted")) 
            .observeOn(Schedulers.computation())
            .doOnError(e -> System.err.println("Thread:" + Thread.currentThread().getName() + "\tonError: " + e.getMessage()))
            .subscribe();

    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```
<br>
<br>

# [flatMap](http://reactivex.io/documentation/operators/flatmap.html)
현재 Observable에 의해 발생되는 항목들 중 Observable이 있다면 그 Observable이 발생시킨 항목들도 현재 스트림에서 흐르게 합니다. 항목들의 항목들도 하나의 흐름으로 merge 시키는 겁니다.

![flatMap.c.png](http://reactivex.io/documentation/operators/images/flatMap.c.png)

### 샘플 코드
```java
// RxJava1

```
<br>
<br>
