# [from](http://reactivex.io/documentation/operators/from.html)
배열, iterable 데이터를 Observable로 만들 수 있는 연산자입니다. 
![from.c.png](http://reactivex.io/documentation/ko/operators/images/from.c.png)

### 샘플 코드
```java
// RxJava1
public static void main(String[] args) {
    Observable
            .from(new Integer[]{1, 2, 3})
            .doOnEach(notification -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tEach: " + notification))
            .subscribeOn(Schedulers.computation())
            .observeOn(Schedulers.io())
            .map(item -> {
                System.out.println("Thread:" + Thread.currentThread().getName() + "\tMap: " + item);
                return item * item;
            })
            .observeOn(Schedulers.newThread())
            .doOnNext(item -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tonNext: " + item))
            .observeOn(Schedulers.io())
            .doOnCompleted(() -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tonCompleted"))
            .observeOn(Schedulers.computation())
            .doOnError(e -> System.err.println("Thread:" + Thread.currentThread().getName() + "\tonError: " + e.getMessage()))
            .subscribe();

    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```
<br>

# [interval](http://reactivex.io/documentation/operators/interval.html)
주어진 시간을 간격으로 흘러간 시간 데이터를 발생시키는 Observable을 만듭니다.
![interval.c.png](http://reactivex.io/documentation/operators/images/interval.c.png)

### 샘플 코드
```java
// RxJava1
public static void main(String[] args) {
    Subscription subscription = Observable
            .interval(500, 500, TimeUnit.MILLISECONDS) // 500ms 후부터 500ms마다 onNext
            .doOnEach(notification -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tEach: " + notification))
            .subscribeOn(Schedulers.computation())
            .observeOn(Schedulers.io())
            .map(item -> {
                System.out.println("Thread:" + Thread.currentThread().getName() + "\tMap: " + item);
                return item * item;
            })
            .observeOn(Schedulers.newThread())
            .doOnNext(item -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tonNext: " + item))
            .observeOn(Schedulers.io())
            .doOnCompleted(() -> System.out.println("Thread:" + Thread.currentThread().getName() + "\tonCompleted")) // 호출되지 않습니다.
            .observeOn(Schedulers.computation())
            .doOnError(e -> System.err.println("Thread:" + Thread.currentThread().getName() + "\tonError: " + e.getMessage()))
            .subscribe();

    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```
